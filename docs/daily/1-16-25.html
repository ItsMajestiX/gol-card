<!DOCTYPE html> <html lang="en"><head>
<title>1-16-25</title>
<base href="..">
<meta name="pathname" content="daily/1-16-25.html">
<meta name="description" content="gol_card_docs - 1-16-25">
<meta property="og:title" content="1-16-25">
<meta property="og:description" content="gol_card_docs - 1-16-25">
<meta property="og:type" content="website">
<meta property="og:url" content="daily/1-16-25.html">
<meta property="og:image" content="undefined">
<meta charset="UTF-8"><meta property="og:site_name" content="gol_card_docs"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=1.0, maximum-scale=5.0"><script async="" id="webpage-script" src="site-lib/scripts/webpage.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="graph-wasm-script" src="site-lib/scripts/graph-wasm.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="graph-render-worker-script" src="site-lib/scripts/graph-render-worker.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><link rel="icon" href="site-lib/media/favicon.png"><link rel="stylesheet" href="site-lib/styles/obsidian.css"><link rel="preload" href="site-lib/styles/global-variable-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="site-lib/styles/global-variable-styles.css"></noscript><link rel="preload" href="site-lib/styles/main-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="site-lib/styles/main-styles.css"></noscript><style>body{--line-width:40em;--line-width-adaptive:40em;--file-line-width:40em;--sidebar-width:min(20em, 80vw);--collapse-arrow-size:11px;--tree-vertical-spacing:1.3em;--sidebar-margin:12px}:root{background-color:#202124}.sidebar{height:100%;font-size:14px;z-index:10;min-width:calc(var(--sidebar-width) + var(--divider-width-hover));max-width:calc(var(--sidebar-width) + var(--divider-width-hover));position:relative;overflow:hidden;overflow:clip;transition:min-width ease-in-out,max-width ease-in-out;transition-duration:.2s;contain:size}#left-sidebar{left:0}#right-sidebar{right:0}.sidebar.is-collapsed{min-width:0;max-width:0}.sidebar.floating{position:absolute}.sidebar .leaf-content{height:100%;min-width:calc(var(--sidebar-width) - var(--divider-width-hover));top:0;padding:var(--sidebar-margin);padding-top:4em;line-height:var(--line-height-tight);background-color:var(--background-secondary);transition:background-color,border-right,border-left,box-shadow;transition-duration:var(--color-fade-speed);transition-timing-function:ease-in-out;position:absolute;display:flex;flex-direction:column}.sidebar:not(.is-collapsed) .leaf-content{min-width:calc(max(100%,var(--sidebar-width)) - 3px);max-width:calc(max(100%,var(--sidebar-width)) - 3px)}#left-sidebar-content{left:0;border-top-right-radius:var(--radius-l);border-bottom-right-radius:var(--radius-l)}#right-sidebar-content{right:0;border-top-left-radius:var(--radius-l);border-bottom-left-radius:var(--radius-l)}.sidebar #left-sidebar-content,.sidebar #right-sidebar-content{contain:none!important;container-type:normal!important;animation:none!important}.sidebar:has(.leaf-content:empty):has(.topbar-content:empty){display:none}.sidebar-topbar{height:calc(2.3em + 2 * var(--sidebar-margin));width:var(--sidebar-width);padding:var(--sidebar-margin);z-index:1;position:fixed;display:flex;align-items:center;transition:width ease-in-out;transition-duration:inherit}.sidebar.is-collapsed .sidebar-topbar{width:calc(2.3em + var(--sidebar-margin) * 2)}.sidebar .sidebar-topbar.is-collapsed{width:0}#left-sidebar .sidebar-topbar{left:0;flex-direction:row;border-top-right-radius:var(--radius-l)}#right-sidebar .sidebar-topbar{right:0;flex-direction:row-reverse;border-top-left-radius:var(--radius-l)}#left-sidebar .topbar-content{margin-right:calc(2.3em + var(--sidebar-margin));flex-direction:row}#right-sidebar .topbar-content{margin-left:calc(2.3em + var(--sidebar-margin));flex-direction:row-reverse}.topbar-content{overflow:hidden visible;overflow:clip visible;width:100%;height:100%;display:flex;align-items:center;transition:inherit}.sidebar.is-collapsed .topbar-content{width:0;transition:inherit}.clickable-icon.sidebar-collapse-icon{background-color:transparent;color:var(--icon-color-focused);padding:2px!important;margin:0!important;height:100%!important;width:2.3em!important;margin-inline:0.14em!important;position:absolute}#left-sidebar .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);right:var(--sidebar-margin)}#right-sidebar .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);left:var(--sidebar-margin)}.clickable-icon.sidebar-collapse-icon svg.svg-icon{width:100%;height:100%}.feature-title{margin-left:1px;text-transform:uppercase;letter-spacing:.06em;margin-top:.75em;margin-bottom:.75em}.feature-header{display:flex;align-items:center;padding-top:0;font-size:1em;padding-left:0}body.floating-sidebars .sidebar{position:absolute}body{transition:background-color var(--color-fade-speed) ease-in-out}#navbar:not(:empty){display:flex;align-items:center;justify-content:space-between;padding:.5em 1em;width:100%}#main{display:flex;flex-direction:column;height:100%;width:100%;align-items:stretch;justify-content:center}#main-horizontal{display:flex;flex-direction:row;flex-grow:1;width:100%;align-items:stretch;justify-content:center}#center-content{flex-basis:100%;max-width:100%;width:100%;height:100%;display:flex;flex-direction:column;align-items:center;transition:opacity .2s ease-in-out;contain:inline-size}.hide{opacity:0!important;transition:opacity .2s ease-in-out;pointer-events:none}#center-content>.obsidian-document{padding-left:2em;padding-right:1em;margin-bottom:0;width:100%;width:-webkit-fill-available;width:-moz-available;width:fill-available;transition:background-color var(--color-fade-speed) ease-in-out;border-top-right-radius:var(--window-radius,var(--radius-m));border-top-left-radius:var(--window-radius,var(--radius-m));overflow-x:hidden!important;overflow-y:auto!important;display:flex!important;flex-direction:column!important;align-items:center!important;contain:inline-size}body #center-content>.obsidian-document>.markdown-preview-sizer{padding-bottom:80vh;width:100%;max-width:var(--line-width);flex-basis:var(--line-width);transition:background-color var(--color-fade-speed) ease-in-out;contain:inline-size}#center-content>.obsidian-document>div{width:100%!important;transition:background-color var(--color-fade-speed) ease-in-out;contain:inline-size}#center-content>.obsidian-document:not([data-type=markdown]).embed{display:flex;padding:1em;height:100%;width:100%;align-items:center;justify-content:center}#center-content>.obsidian-document:not([data-type=markdown]).embed>*{max-width:100%;max-height:100%;object-fit:contain}:not(h1,h2,h3,h4,h5,h6,li):has(> :is(.math,table)){overflow-x:auto!important}#center-content>.obsidian-document:not([data-type=markdown]){overflow-x:auto;contain:content;padding:0;margin:0;height:100%}.obsidian-document[data-type=attachment]{display:flex;flex-direction:column;align-items:center;justify-content:center;height:100%;width:100%}.obsidian-document[data-type=attachment]>*{outline:0;border:none;box-shadow:none}.obsidian-document[data-type=attachment] :is(img){max-width:90%;max-height:90%;object-fit:contain}.obsidian-document[data-type=attachment]>:is(audio){width:100%;max-width:min(90%,var(--line-width))}.obsidian-document[data-type=attachment]>:is(embed,iframe,video){width:100%;height:100%;max-width:100%;max-height:100%;object-fit:contain}.canvas-wrapper>:is(.header,.footer){z-index:100;position:absolute;display:flex;justify-content:center;flex-direction:column;width:100%;align-items:center}.scroll-highlight{position:absolute;width:100%;height:100%;pointer-events:none;z-index:1000;background-color:hsla(var(--color-accent-hsl),.25);opacity:0;padding:1em;inset:50%;translate:-50% -50%;border-radius:var(--radius-s)}</style><script defer="">async function loadIncludes(){let e=document.querySelectorAll("link[itemprop='include']");for(const t of e){let e=t.getAttribute("href");try{let o="";if(e.startsWith("https:")||e.startsWith("http:")||"file:"!=window.location.protocol){const n=await fetch(e);if(!n.ok){console.log("Could not include file: "+e),t?.remove();continue}o=await n.text()}else{const t=document.getElementById(btoa(encodeURI(e)));if(t){const e=JSON.parse(decodeURI(atob(t.getAttribute("value")??"")));o=e?.data??""}}let n=document.createRange().createContextualFragment(o);t.before(n),t.remove(),console.log("Included text: "+o),console.log("Included file: "+e)}catch(o){t?.remove(),console.log("Could not include file: "+e,o);continue}}}document.addEventListener("DOMContentLoaded",(()=>{loadIncludes()}));let isFileProtocol="file:"==location.protocol;function waitLoadScripts(e,t){let o=e.map((e=>document.getElementById(e+"-script")));!function e(n){let l=o[n],c=n+1;l?(l&&"true"!=l.getAttribute("loaded")||n<o.length&&e(c),n<o.length&&l.addEventListener("load",(()=>e(c)))):n<o.length?e(c):t()}(0)}</script></head><body class="publish css-settings-manager styled-scrollbars show-inline-title show-ribbon is-focused"><script defer="">let theme=localStorage.getItem("theme")||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light");"dark"==theme?(document.body.classList.add("theme-dark"),document.body.classList.remove("theme-light")):(document.body.classList.add("theme-light"),document.body.classList.remove("theme-dark")),window.innerWidth<480?document.body.classList.add("is-phone"):window.innerWidth<768?document.body.classList.add("is-tablet"):window.innerWidth<1024?document.body.classList.add("is-small-screen"):document.body.classList.add("is-large-screen")</script><div class="parsed-feature-container" style="display: contents;"><link itemprop="include" href="site-lib/html/custom-head-content-content.html"></div><div id="main"><div id="navbar"></div><div id="main-horizontal"><div id="left-content" class="leaf" style="--sidebar-width: var(--sidebar-width-left);"><div id="left-sidebar" class="sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"><div id="search-container"><div id="search-wrapper"><input enterkeyhint="search" type="search" spellcheck="false" placeholder="Search..."><div aria-label="Clear search" id="search-clear-button"></div></div></div></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content-wrapper"><div id="left-sidebar-content" class="leaf-content"><link itemprop="include" href="site-lib/html/file-tree-content.html"></div></div><script defer="">let ls = document.querySelector("#left-sidebar"); ls.classList.toggle("is-collapsed", window.innerWidth < 768); ls.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-left-width"));</script></div></div><div id="center-content" class="leaf"><div class="obsidian-document markdown-preview-view markdown-rendered node-insert-event is-readable-line-width allow-fold-headings allow-fold-lists show-indentation-guide show-properties" data-type="markdown"><style id="MJX-CHTML-styles"></style><div class="markdown-preview-sizer markdown-preview-section"><div class="header"><h1 class="page-title heading inline-title" id="1-16-25_0">1-16-25</h1><div class="data-bar"></div></div><div class="markdown-preview-pusher" style="width: 1px; height: 0.1px; margin-bottom: 0px;"></div><div class="el-p"><p dir="auto">I've spent the past few days working on the eInk display interface. This has been a very complicated task, requiring an expansion of the codebase as well as thinking about how to structure interrupts in order to make effective use of time. As of right now, the code should be able to enable the display, step the board while sending data to the display, refresh and shut down the display, before entering an infinite loop. However, this code is so complicated that there are probably a few bugs in it. I want to go over the new display code so that I can hopefully catch any errors before I begin trying everything out on actual hardware. Debugging issues like these will be pretty hard, so I want to try and stamp out any bugs beforehand.</p></div><div class="el-h1"><h1 data-heading="Initialization" dir="auto" class="heading" id="Initialization_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>Initialization</h1></div><div class="el-p"><p dir="auto">The code starts in the same way it has previously.  The main function calls the common step function, which calls the platform specific <code>preUpdate</code> function. This function is where the magic starts. It starts off by disabling the watchdog timer and speeding up the CPU clock to 16MHz, the maximum. There is a slight modification to produce a submaster clock for the SPI module, but other than that it should be the same as before. We then run into the first new addition to the codebase, digital IO control.</p></div><div class="el-h1"><h1 data-heading="`dio.zig`" dir="auto" class="heading" id="`dio.zig`_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span><code>dio.zig</code></h1></div><div class="el-p"><p dir="auto">Since my last update, I have reorganized code that interacts directly with hardware registers. There is a <code>msp430</code> folder inside of <code>src</code> with files for each module in module in the processor that I use. These are all re-exported in a <code>msp430.zig</code> file in the <code>src</code> directory, along with some commonly used assembly functions like a nop and global interrupt enable and disable.</p></div><div class="el-p"><p dir="auto">One of these modules is the digital IO system. I have taken advantage of Zig's compile time features to produce a system that turn calls to update the pin to single lines of assembly. In the file, there is a <code>DigitalIO</code> type function that takes in an enum of the available ports on the MSP430FR2433 and returns a custom type with functions that set the pins on that specific port. I then have another type function <code>Pin</code> that takes in one of these types and a pin number and produces functions that affect just that pin. Most of the functions are fairly standard: pin direction, pin mode, pin output, things like that. There is one more advanced function though: the <code>waitForChange</code> function. This function takes in a pin on a port and either the rising or falling edge of the signal. The function then enable the pin's interrupt and puts the CPU in LPM4 waiting for the transition to happen. Using the comptime system, each declared port exports its own interrupt handler that clears both the interrupt enable and interrupt flag registers of the port and returns the CPU to regular operation. This also makes sure that trying to use the function on pins in a port that doesn't support interrupts will cause a compile time error. This actually saved me from forgetting to switch pins around.</p></div><div class="el-p"><p dir="auto">I also caught an issue while writing this. I noticed that some interrupts were just calls to others, which messes up the stack. I added the reset functionality to the handler to force them to be separate.</p></div><div class="el-p"><p dir="auto">In this file I export the three ports on the chip, and in a <code>pins.zig</code> file I export all of the pins that the program uses. This allows me to change pin numbers and ports around without having to hunt through code.</p></div><div class="el-p"><p dir="auto">Going back to the main program flow, the <code>preUpdate</code> function resets all of the DIO ports to a safe state, before setting up the eUSCI module.</p></div><div class="el-h1"><h1 data-heading="`eusci.zig`" dir="auto" class="heading" id="`eusci.zig`_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span><code>eusci.zig</code></h1></div><div class="el-p"><p dir="auto">SPI on these chips is handled by the "enhanced universal serial communication interface", or eUSCI module. These modules can be configured in one of multiple modes to handle various types of communication, including SPI, I2C, and UART. The file starts off with creating interfaces to the various registers needed for SPI control of eUSCI B, which is the only one that this project uses. Some are packed structs, others are plain integers.</p></div><div class="el-p"><p dir="auto">This file is also where <code>initSPI</code> lives. It starts off by placing the eUSCI module in a software reset state so its settings can be modified. It is then configured to match the signal that the display driver expects. One small issue is that the driver datasheet recommends that CS be pulsed in between bytes to prevent noise from interfering. Unless the module does this automatically, I don't see an easy way to implement this behavior. One important thing that is configured is an MSB first byte order. This is specified in the driver datasheet. However, we will use LSB later on to correct for how the board data is stored in FRAM.</p></div><div class="el-p"><p dir="auto">The pins for the eUSCI are then configured for the appropriate purpose, and the software reset is lifted. Back in the <code>preUpdate</code> function, the pin connected to the busy pin of the display driver is set to an input. The display is then initialized.</p></div><div class="el-h1"><h1 data-heading="`display.zig`" dir="auto" class="heading" id="`display.zig`_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span><code>display.zig</code></h1></div><div class="el-p"><p dir="auto">This file contains all of the logic for setting up, refreshing, and powering down the display. Lots of the code there is base on Waveshare's example code for the display, so I added the licence notices for the files I used at the top. The file starts off with a few arrays of LUT data that are sent to the display later on. There are then a few functions that power off and refresh the display that will be covered later. </p></div><div class="el-p"><p dir="auto">The initialize function for the device is not very complicated. All it does is reset the device by toggling the reset pin. It used to also power up the device with a GPIO, but I went and checked the datasheet and found out that display can draw up to 40 mA. I plan on powering the device straight from 3V instead. After this, the function calls a function in the eUSCI file called setFetchData. And this is where things get complicated.</p></div><div class="el-h1"><h1 data-heading="The SPI Interrupt System" dir="auto" class="heading" id="The_SPI_Interrupt_System_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>The SPI Interrupt System</h1></div><div class="el-p"><p dir="auto">The program need to send various commands and data to the display. It must do this by transmitting bytes over SPI while setting a select line high or low to indicate the kind of data being sent. While this is going on, the program is also working to advance the board to its next state. The program could do everything synchronously after the board is done updating, but by having the data being transmitted while the program is running we can take advantage of the time (64 cycles?) it takes to send a byte out. What makes this hard is that the microcontroller does not have a DMA on it. All of the data that we need to send must be manually copied by the CPU to the SPI module. This means that any code that is executing will be regularly interrupted to place a new byte into the SPI transmit buffer.</p></div><div class="el-p"><p dir="auto">Creating a system with all of this in mind took a while. I believe that my solution gives high performance while still being flexible.</p></div><div class="el-h2"><h2 data-heading="Getting Interrupts to Work in Zig" dir="auto" class="heading" id="Getting_Interrupts_to_Work_in_Zig_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>Getting Interrupts to Work in Zig</h2></div><div class="el-p"><p dir="auto">The first step in this process was figuring out how to make an interrupt in Zig in the first place. The linker expects interrupts to be functions exported to a special section. For many architectures, Zig has a built in interrupt calling convention that tells LLVM how to make the function behave in the correct manner. LLVM actually has a setting for MSP430 interrupts, but it is not implemented in the version of Zig that I'm using. This left me with two options</p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto">Add the MSP430 interrupt calling convention to Zig.</li>
<li data-line="1" dir="auto">Use inline assembly to make a regular function work as an interrupt.</li>
</ol></div><div class="el-p"><p dir="auto">I acutally started out with option 1. I set up a development environment for Zig and got to work. The changes were actually fairly simple, and I tried to build them. I then realized that there is an <a data-tooltip-position="top" aria-label="https://github.com/ziglang/zig/issues/21842" rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/ziglang/zig/issues/21842" target="_self">unresolved issue</a> in the Zig complier that makes it impossible to change the code that handles calling conventions...at least until I went to check just now. I may try and get my changes to work, but for now I'm going to keep my code based on option #2.</p></div><div class="el-p"><p dir="auto">Option #2 is actually not as bad as I first thought. The main differences between a regular function and an interrupt are register save/restore and a special <code>reti</code> instruction. What I ended up doing is coding the interrupt as normal, building the assembly, and then manually checking to see which registers were used by the interrupt. I added assembly to manually save and restore these registers to and from the stack, as well as ending the function with a <code>reti</code> instruction.</p></div><div class="el-h2"><h2 data-heading="The SPI Interrupt" dir="auto" class="heading" id="The_SPI_Interrupt_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>The SPI Interrupt</h2></div><div class="el-p"><p dir="auto">The SPI interrupt code lives in <code>eUSCI.zig</code>. It starts by using an inline assembly block to push the three registers used in the code to the stack. It then takes the first item from a global slice variable called <code>to_send</code> and copies it to the SPI transmit buffer. It then creates a new slice without that element and checks if it is empty. If it is not, it replaces <code>to_send</code> with the temporary slice. If it is empty, it calls the function pointed to by the <code>fetch_data</code> global variable. Having this <code>fetch_data</code> function allows the IRQ to get new data immediately when it runs out without having to wait for the main program to feed it more. One it returns, the interrupt checks if <code>to_slice</code> is still empty. This should only happen once the code is done sending the entire board to the display. If it is, it makes sure the CPU will wake up from LPM0 if it currently in that state. This will come into play later on. Finally, the interrupt  restores registers and returns.</p></div><div class="el-h2"><h2 data-heading="`setupFetchData`" dir="auto" class="heading" id="`setupFetchData`_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span><code>setupFetchData</code></h2></div><div class="el-p"><p dir="auto">Returning to the main program flow, the <code>setFetchData</code> function does two things. It replaces the current <code>fetch_data</code> value with the given function, and then runs that function. The function given by the display init function is called <code>setupFetchData</code>, and goes through the entire display configuration process. The function body is a state machine. It is a giant switch block, where each case increments a counter to move to the next case the next time the function is executed.</p></div><div class="el-p"><p dir="auto">There are 9 steps in the function, but many of them are similar in flow. Let's take a look at step zero, the one that will be ran from the main program. It starts by pulling the data/command line low to indicate a command byte, before sending the appropriate byte using a function called sendDataSync. This function copies the data to the transmit buffer and then busy waits until the eUSCI module is not busy anymore. This is not ideal, but:</p></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span>there is no interrupt for this event, so going into LPM and getting woken up by the SPI module is not possible</li>
<li data-line="1" dir="auto"><span class="list-bullet"></span>switching to VLOCLK (a built in 10kHz clock) would overshoot as the transmission takes places in less time than the period of the clock</li>
<li data-line="2" dir="auto"><span class="list-bullet"></span>slowing down MCLK is a problem because the SMCLK line that the SPI module is tied to is sourced from it</li>
<li data-line="3" dir="auto"><span class="list-bullet"></span>the correct way, using a timer to generate an interrupt, is not something I want to deal with at the moment.<br>
We need to wait until all pending data has been transmitted because the next byte(s) transmitted will need to have the data/command line pulled high to mark them as data. This is a common pattern throughout this function.</li>
</ul></div><div class="el-p"><p dir="auto">This goes on for a few arguments, before a different pattern takes place. The variable that keeps track of the state is incremented, and a function from the eUSCI file called <code>sendSlice</code> is called with a slice full of data bytes that need to be sent. This function works similarly to the interrupt handler itself, attemping to add as many bytes as possible before setting <code>to_send</code> to the the slice with remaining bytes. Once this is done, <code>setupFetchData</code> enables the transmit SPI interrupt. From now on, all calls to the <code>setupFetchData</code> will be done from the interrupt handler.</p></div><div class="el-p"><p dir="auto">Back in the main <code>preUpdate</code> function, the global interrupt handler is enabled so that the transmit interrupt enable will take effect. From now until the the <code>postUpdate</code> function is called, the code behaves very similarly to before, with some minor differences that interact with another <code>fetch_data</code> function that we will talk about soon.</p></div><div class="el-p"><p dir="auto">The remainder of the cases in the switch statement are called in the interrupt. Cases 0-2 are fairly similar, only sending a few configuration bytes. Cases 3-7 are also similar, as they send larger arrays of LUT data to the display. In case 8, only one command byte is sent. The daa/command line is set to data, and the SPI module is put back into software reset. This is just to change the byte ordering to LSB. The program stores the board in a bitfield where the least significant byte is the left most pixel (7 6 5 4 3 2 1 0, 15 14 13 12 11 10 9 8). The display wants data where the most significant byte is the leftmost pixel (0 1 2 3 4 5 6 7, 8 9 10 11 12 13 14 15). We can avoid rotating the data around by just asking the eUSCI module to transmit LSB first. The display will interpret the bits MSB first and reverse the order for us. After doing this, it resets the counter variable to zero to prevent any undefined behavior should the function be called again, and calls <code>setFetchData</code> to change <code>fetch_data</code> to a new function, <code>imageFetchData</code>.</p></div><div class="el-h1"><h1 data-heading="`imageFetchData`" dir="auto" class="heading" id="`imageFetchData`_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span><code>imageFetchData</code></h1></div><div class="el-p"><p dir="auto"><code>imageFetchData</code> is the handler responsible for feeding the interrupt with data to be shown on the display. It is fairly simple. Two global variables, <code>lowest_sent</code> and <code>pending</code>, are used to keep information about what data has been or is being transmitted and what data to send next, respectively. If they are ever equal, meaning that no new data is ready to send at the moment, the function sets a global <code>stall</code> flag and doesn't update <code>to_send</code>. This causes the interrupt handler to disable itself and wake the CPU from LPM0 if active. In addition, if the value of both variables is equal to the length of the bitset, another flag named <code>complete</code> is set. After these checks, the board is sliced between <code>lowest_sent</code> and <code>pending</code> and sent using <code>sendSlice</code>. <code>pending</code> is then copied to <code>lowest_sent</code> to make sure data is not retransmitted.</p></div><div class="el-h2"><h2 data-heading="`markComplete` and `markAllComplete`" dir="auto" class="heading" id="`markComplete`_and_`markAllComplete`_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span><code>markComplete</code> and <code>markAllComplete</code></h2></div><div class="el-p"><p dir="auto">The variable <code>pending</code> is updated by the functions <code>markComplete</code> and <code>markAllComplete</code>. <code>markComplete</code> increments <code>pending</code> by the number of bytes in one row of the board. <code>markAllComplete</code> sets <code>pending</code> to the length of the bitset that stores the board. In addition, they check if the <code>stall</code> flag has been set. If it has, they clear it and reenable the interrupt. As the stall flag is only set when space is available in the TX buffer yet there is no new data to transmit, this should cause an immediate interrupt.</p></div><div class="el-h1"><h1 data-heading="`postUpdate`" dir="auto" class="heading" id="`postUpdate`_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span><code>postUpdate</code></h1></div><div class="el-p"><p dir="auto">Once the board has been updated and any other steps are done, the common code calls <code>hal.postUpdate</code>. In the embedded version of the HAL, this takes care of refreshing and powering down the display and will eventually set up the MSP430 to go to sleep for a certain amount of time before repeating everything all over again. It starts by write protecting the FRAM as usual, before disabling interrupts. This is because the code needs to check if the complete flag has been set, and having the flag set after the check fails would cause a softlock. If the flag has been set, it continues. If not, it places the CPU in LPM0 while it waits for the SPI system to finish sending the remaining display data. The interrupt handler contains code to wake the processor from LPM0 if it detects it has no more data to transmit. By this point the entire board is made available, so this should only happen once all of the display data has been sent. After this, the program waits for any remaining data in the eUSCI module to be sent before switching the bit order back to MSB first. </p></div><div class="el-p"><p dir="auto">It then calls a function to get the display to refresh and actually display the image data. It starts off like normal, sending a command and data byte synchronously to trigger the refresh. The code then busy waits for about a millisecond (using a 10kHz clock), before shutting down the SPI module. This is to make sure that the SPI's need for a clock module does not interfere with the next step. By this time, the display should have set its busy line to low. The <code>waitForChange</code> function is then ran on the display's busy pin, saving power until it has finished the refresh and sets the busy line high. Once this has completed, the SPI is reenabled to issue the last command to put the display into deep sleep.</p></div><div class="el-p"><p dir="auto">After this, the step function returns and the program enters a spin loop as of right now.</p></div><div class="el-h1"><h1 data-heading="Next Steps" dir="auto" class="heading" id="Next_Steps_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>Next Steps</h1></div><div class="el-p"><p dir="auto">It's currently late as I'm writing this, so I plan to try out this code on hardware tomorrow. I did catch four issues by my count doing this check, so that's good. I don't expect this to work on the first try still, as there are so many moving parts here that something is bound to go wrong. The problem is that it will be hard to debug any issues involving the SPI connection without hardware tools. Debugging the software side of things will be hard, but possible.</p></div><div class="el-p"><p dir="auto">I have also realized that I am running out of time to get this project done in time for UW-Madison's career fair. It is less than a month away, and I do not have a working prototype yet. My plan is to begin work on the PCB design once the display works and add the remaining features while I wait for parts.</p></div><div class="footer"><div class="data-bar"></div></div></div></div></div><div id="right-content" class="leaf" style="--sidebar-width: var(--sidebar-width-right);"><div id="right-sidebar" class="sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"><label class="theme-toggle-container" for="theme-toggle-input" id=""><input class="theme-toggle-input" type="checkbox" id="theme-toggle-input"><div class="toggle-background"></div></label></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content-wrapper"><div id="right-sidebar-content" class="leaf-content"><div class="graph-view-wrapper"><div class="feature-header"><div class="feature-title">Interactive Graph</div></div><div class="graph-view-placeholder">
		<div class="graph-view-container">
			<div class="graph-icon graph-expand" role="button" aria-label="Expand" data-tooltip-position="top"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><line x1="7" y1="17" x2="17" y2="7"></line><polyline points="7 7 17 7 17 17"></polyline></svg></div>
			<div class="graph-icon graph-global" role="button" aria-label="Global Graph" data-tooltip-position="top"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-git-fork"><circle cx="12" cy="18" r="3"></circle><circle cx="6" cy="6" r="3"></circle><circle cx="18" cy="6" r="3"></circle><path d="M18 9v2c0 .6-.4 1-1 1H7c-.6 0-1-.4-1-1V9"></path><path d="M12 12v3"></path></svg></div>
			<canvas id="graph-canvas" class="hide" width="512px" height="512px"></canvas>
		</div>
		</div></div><div id="outline" class=" tree-container"><div class="feature-header"><div class="feature-title">Table Of Contents</div><button class="clickable-icon nav-action-button tree-collapse-all" aria-label="Collapse All"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></svg></button></div><div class="tree-item" data-depth="1"><a class="tree-item-self is-clickable" href="daily/1-16-25.html#1-16-25_0" data-path="#1-16-25_0"><div class="tree-item-inner heading-link" heading-name="1-16-25">1-16-25</div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="1"><a class="tree-item-self is-clickable" href="daily/1-16-25.html#Initialization_0" data-path="#Initialization_0"><div class="tree-item-inner heading-link" heading-name="Initialization">Initialization</div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="1"><a class="tree-item-self is-clickable" href="daily/1-16-25.html#`dio.zig`_0" data-path="#`dio.zig`_0"><div class="tree-item-inner heading-link" heading-name="`dio.zig`"><code>dio.zig</code></div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="1"><a class="tree-item-self is-clickable" href="daily/1-16-25.html#`eusci.zig`_0" data-path="#`eusci.zig`_0"><div class="tree-item-inner heading-link" heading-name="`eusci.zig`"><code>eusci.zig</code></div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="1"><a class="tree-item-self is-clickable" href="daily/1-16-25.html#`display.zig`_0" data-path="#`display.zig`_0"><div class="tree-item-inner heading-link" heading-name="`display.zig`"><code>display.zig</code></div></a><div class="tree-item-children"></div></div><div class="tree-item mod-collapsible" data-depth="1"><a class="tree-item-self is-clickable mod-collapsible" href="daily/1-16-25.html#The_SPI_Interrupt_System_0" data-path="#The_SPI_Interrupt_System_0"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><div class="tree-item-inner heading-link" heading-name="The SPI Interrupt System">The SPI Interrupt System</div></a><div class="tree-item-children"><div class="tree-item" data-depth="2"><a class="tree-item-self is-clickable" href="daily/1-16-25.html#Getting_Interrupts_to_Work_in_Zig_0" data-path="#Getting_Interrupts_to_Work_in_Zig_0"><div class="tree-item-inner heading-link" heading-name="Getting Interrupts to Work in Zig">Getting Interrupts to Work in Zig</div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-item-self is-clickable" href="daily/1-16-25.html#The_SPI_Interrupt_0" data-path="#The_SPI_Interrupt_0"><div class="tree-item-inner heading-link" heading-name="The SPI Interrupt">The SPI Interrupt</div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-item-self is-clickable" href="daily/1-16-25.html#`setupFetchData`_0" data-path="#`setupFetchData`_0"><div class="tree-item-inner heading-link" heading-name="`setupFetchData`"><code>setupFetchData</code></div></a><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="1"><a class="tree-item-self is-clickable mod-collapsible" href="daily/1-16-25.html#`imageFetchData`_0" data-path="#`imageFetchData`_0"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><div class="tree-item-inner heading-link" heading-name="`imageFetchData`"><code>imageFetchData</code></div></a><div class="tree-item-children"><div class="tree-item" data-depth="2"><a class="tree-item-self is-clickable" href="daily/1-16-25.html#`markComplete`_and_`markAllComplete`_0" data-path="#`markComplete`_and_`markAllComplete`_0"><div class="tree-item-inner heading-link" heading-name="`markComplete` and `markAllComplete`"><code>markComplete</code> and <code>markAllComplete</code></div></a><div class="tree-item-children"></div></div></div></div><div class="tree-item" data-depth="1"><a class="tree-item-self is-clickable" href="daily/1-16-25.html#`postUpdate`_0" data-path="#`postUpdate`_0"><div class="tree-item-inner heading-link" heading-name="`postUpdate`"><code>postUpdate</code></div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="1"><a class="tree-item-self is-clickable" href="daily/1-16-25.html#Next_Steps_0" data-path="#Next_Steps_0"><div class="tree-item-inner heading-link" heading-name="Next Steps">Next Steps</div></a><div class="tree-item-children"></div></div></div></div></div><script defer="">let rs = document.querySelector("#right-sidebar"); rs.classList.toggle("is-collapsed", window.innerWidth < 768); rs.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-right-width"));</script></div></div></div></div></body></html>